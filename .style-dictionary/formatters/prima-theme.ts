import type { Dictionary, FormatFn } from 'style-dictionary/types';
import { format } from 'prettier';
import { autogeneratedComment } from '../constant.js';

export const primaThemeFormatter: FormatFn = ({
  dictionary,
}: {
  dictionary: Dictionary;
}) => {
  const tokens = dictionary.tokens;

  const tokenLookup = flattenTokens(tokens);

  const resolvedTokens = resolveReferences(tokens, tokenLookup);

  function buildThemeObject(obj: any, path: string[] = []): string {
    const entries: string[] = [];

    for (const [key, value] of Object.entries(obj)) {
      const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;

      if (value && typeof value === 'object' && '$value' in value) {
        const token = value as any;
        const tokenValue = token.$value;
        let formattedValue: string;

        if (
          token.$type === 'color' ||
          (typeof tokenValue === 'string' && tokenValue.startsWith('#'))
        ) {
          formattedValue = `'${tokenValue}'`;
        } else if (typeof tokenValue === 'string') {
          formattedValue = `'${tokenValue}'`;
        } else {
          formattedValue = String(tokenValue);
        }

        entries.push(`  ${safeKey}: ${formattedValue}`);
      } else if (value && typeof value === 'object' && !('$value' in value)) {
        const nestedContent = buildThemeObject(value, [...path, key]);
        entries.push(`  ${safeKey}: {\n${nestedContent}\n  }`);
      }
    }

    return entries.join(',\n');
  }

  const themeContent = buildThemeObject(resolvedTokens);

  const output = `${autogeneratedComment}export const primaTheme = {${themeContent}} as const;

export type PrimaTheme = typeof primaTheme;
`;

  try {
    return format(output, {
      parser: 'typescript',
      singleQuote: true,
      trailingComma: 'es5',
    });
  } catch (error) {
    console.warn(
      'Prettier formatting failed, returning unformatted code:',
      error
    );
    return output;
  }
};

function flattenTokens(obj: any, prefix = ''): Record<string, any> {
  const result: Record<string, any> = {};

  for (const [key, value] of Object.entries(obj)) {
    const newPrefix = prefix ? `${prefix}.${key}` : key;

    if (value && typeof value === 'object' && '$value' in value) {
      result[newPrefix] = value.$value;
    } else if (value && typeof value === 'object') {
      Object.assign(result, flattenTokens(value, newPrefix));
    }
  }

  return result;
}

function resolveReferences(obj: any, lookup: Record<string, any>): any {
  if (Array.isArray(obj)) {
    return obj.map((item) => resolveReferences(item, lookup));
  }

  if (obj && typeof obj === 'object') {
    const result: any = {};

    for (const [key, value] of Object.entries(obj)) {
      if (value && typeof value === 'object' && '$value' in value) {
        const token = value as any;
        if (
          typeof token.$value === 'string' &&
          token.$value.startsWith('{') &&
          token.$value.endsWith('}')
        ) {
          const refPath = token.$value.slice(1, -1);
          const resolvedValue = lookup[refPath];
          result[key] = {
            ...token,
            $value: resolvedValue !== undefined ? resolvedValue : token.$value,
          };
        } else {
          result[key] = token;
        }
      } else {
        result[key] = resolveReferences(value, lookup);
      }
    }

    return result;
  }

  return obj;
}
